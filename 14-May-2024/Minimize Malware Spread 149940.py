# Problem: Minimize Malware Spread - https://leetcode.com/problems/minimize-malware-spread/

class UnionFind:
    def __init__(self, size, infected):
        self.parent = [i for i in range(size)] 
        self.size = [1 for _ in range(size)]
        self.infected = [int(i in infected) for i in range(size)]

    def find(self, x):
        stack = [x]
        while self.parent[x] != x:
            x = self.parent[x]
            stack.append(x)
        for i in stack:
            self.parent[i] = x
        return x
    
    def union(self, x, y):
        rooty = self.find(y)
        rootx = self.find(x)
        if rootx == rooty:
            return
        if self.size[rootx] > self.size[rooty]:
            self.parent[rooty] = rootx
            self.size[rootx] += self.size[rooty]
            self.infected[rootx] += self.infected[rooty]
        else:
            self.parent[rootx] = rooty
            self.size[rooty] += self.size[rootx]
            self.infected[rooty] += self.infected[rootx]

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        uf = UnionFind(len(graph), set(initial))
        for i in range(len(graph)):
            for j in range(i+1, len(graph[0])):
                if graph[i][j] == 1:
                    uf.union(i, j)
        _mins = []
        spread = float("-inf")
  
        for i in initial:
            par = uf.find(i)
            if uf.infected[par] == 1:
                if uf.size[par] > spread:
                    _mins = [i]
                    spread = uf.size[par]
                elif uf.size[par] == spread:
                    _mins.append(i)
        if _mins:
            return min(_mins)
        return min(initial)